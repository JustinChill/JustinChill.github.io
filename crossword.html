<!DOCTYPE html>
<html lang="en">
<head>
  <title>NYT Crossword Puzzle Stats</title>
  <meta charset="UTF-8">
  <link rel="stylesheet" href="style.css" />

  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="Visualizing crossword puzzle performance.">
  <meta name="author" content="Justin Chill">

  <style type="text/css">
    figcaption, figcaption > a {
      text-align: right;
    }
  </style>
</head>
<body>
  <nav class="nav">
    <div class="nav__list">
      <a href="index.html" class="nav__item">Home</a>
      <a href="blog.html" class="nav__item">Blog</a>
      <a href="fun.html" class="nav__item">Fun</a>
    </div>
    <div class="nav__list">
      <a href="http://linkedin.com/in/justinrichardhill/" class="nav__item" target="_blank">LinkedIn</a>
      <a href="#" class="nav__item js-email-link">Email</a>
    </div>
  </nav>
  
  <main role="main">
    <article>
     <div class="article-hero">
      <h2 class="article-category">Post</h2>
      <h1 class="article-title">Crossword Puzzle Stats</h1>
      <h2 class="article-subtitle">Analyzing crossword puzzle performance</h2>
    </div>

    <figure id="xword"></figure>
    <figcaption>Data: <a href="https://www.nytimes.com/crosswords">NYT Crossword</a> app</figcaption>

    <p>The New York Times crossword puzzle app doesn't show much you information about your solve times. I learned it's possible to download your own stats (see <a href="https://github.com/mattdodge/nyt-crossword-stats">here</a>) and decided to do my own analysis. This dataset includes 500 puzzles solved since 2019.</p>

    <figure id="text_stats"></figure>

    <h3>Average time by day of week</h3>
    <figure id="week"></figure>

    <p>The puzzle gets progressively harder as the week goes on, with Saturday being the most challenging day of the week. The Saturday and Sunday puzzles also feature a larger grid of 25x25 squares as compared to a 15x15 weekday puzzle. In the graph above we can see a pretty clear jump from the time it takes to solve Monday, Tuesday, and Wednesday puzzles to solving Thursday and beyond.</p>

    <h3>Puzzles over time</h3>
    <figure id="alltime"></figure>
    <p>A noticeable uptick in puzzle activity since the onset of the pandemic.</p>

    <h3>Puzzles by day of week</h3>
    <figure id="facet"></figure>
    <p>Breaking out each puzzle by it's day of the week helps to make this chart a bit more understandable. You can see that time to solve increases as the week goes on, as puzzles become more challenging later in the week.</p>

    <h3>Constructors</h3>
    <figure id="constructors"></figure>
    <p>Top 20 crossword puzzle constructors in the dataset. I'm glad <a href="https://en.wikipedia.org/wiki/Erik_Agard">Erik Agard</a> is on the list- he's one of my personal favorites. I highly recommend his <a href="https://www.amazon.com/Food-Thought-Crosswords-Erik-Agard/dp/1454916311/ref=sr_1_1?dchild=1&qid=1635195835&refinements=p_27%3AErik+Agard&s=books&sr=1-1">food-themed puzzle book</a> 🤓</p>
    <p><a href="https://rosswordpuzzles.com/whos-ross/">Ross Trudeau</a> takes first place with more than 10 puzzles published in the Times.</p>

  </article>
</main>
<footer>
  <h2 id="footnote-label">Footnotes</h2>
  <div>
    <p>Justin Chill © 2021. Thanks for reading!</p>
    <p><a href="https://github.com/JustinChill/JustinChill.github.io" target="_blank"><img src="imgs/github.svg" class="icon">Source code and feedback</a></p>    
  </div>
</footer>
<script src="https://cdn.jsdelivr.net/npm/d3"></script>
<script src="https://cdn.jsdelivr.net/npm/@observablehq/plot"></script>

<script type="text/javascript">
  // Use Promises to async request data
  var promises = [d3.csv("data/xwstats.csv",d3.autoType)];
  var element = d3.select('figure').node();
  var width = element.getBoundingClientRect().width; // get width of article so graphic is responsive
  var height = 450;
  var size = 12;
  var scheme = "set2";

  // Stats section
  const total = document.querySelectorAll('#total');

  
  // And the plot thickens...
  myDataPromises = Promise.all(promises);

  // After data is successfully fetched, generate viz
  myDataPromises.then(function(data) {
    // Define the data
    var xword_data = data[0];

    var xword = {
      width: width,
      height: height,
      style:{fontSize: size},
      grid: false,
      inset: 10,
      marginBottom: 50,
      marginTop: 25,
      y: {
        // Bug: I think I need to sort days of week in an accessor function
        domain: ["Mo", "Tu", "We", "Th", "Fr", "Sa", "Su"], // days in puzzle difficulty order
        // range: ["Mon", "Tue", "Wed", "Thr", "Fri", "Sat", "Sun"],
        labelAnchor: "Top",
        tickSize: 0,
        tickFormat: d => `${d}.`, // add period after day
      },
      x: {
        tickFormat: ",.2r",
        transform: d => d / 60, // turn seconds into minutes
        label: "Time taken (minutes) →",
        labelAnchor: "center",
        labelOffset: 50,
      },
      color: {
        scheme: "RdYlGn",
        reverse: true,
      },
      marks: [
      Plot.ruleY(xword_data.filter(d => (d.Solved === "True")), Plot.groupY({x1: "min", x2: "max"}, {y: "Day of Week", x: "Time Taken", stroke: "hsl(210, 16%, 82%)"})),
      Plot.tickX(xword_data.filter(d => (d.Solved === "True")), Plot.groupY({x: "median"}, {y: "Day of Week", x: "Time Taken", stroke: "hsl(356, 75%, 53%)"})),
      Plot.dot(xword_data.filter(d => (d.Solved === "True")), {y: "Day of Week", x: "Time Taken", fill: "Time Taken", stroke: "Time Taken", r: 6, title: d => `Constructor: ${d["Constructor"]}\n${d3.format(".4r")(d["Time Taken"]/60)} min to solve`}),
        // title: d => `${d3.timeFormat("%A %B %d, %Y")(d["Puzzle Date"])}\nConstructor: ${d["Constructor"]}\n${d3.format(".4r")(d["Time Taken"]/60)} min to solve`
        Plot.text(xword_data.filter(d => (d.Solved === "True" & d["Day of Week"] === "Sa")), Plot.groupY({x: "median"}, {y: "Day of Week", x: "Time Taken", fill: "hsl(356, 75%, 53%)", fillOpacity: .8, text: d => `← Median time to solve`, dy: -15, dx: 70, fontWeight: 700, fontSize: 12})),
        Plot.frame({stroke: "hsl(210, 16%, 82%)"}),
        ]
      };

      var text_stats = { 
        width: width,
        style:{fontSize: size},
        marginLeft: 20,
        marks: [
        Plot.text(xword_data, Plot.groupY(
          {text: (series) => new d3.InternSet(series).size}),
        {
          y: "Day of Week",
          text: "Solved"
        })
        ]
      };

      var week = {
        width: width,
        style:{fontSize: size},
        marginTop: 50,
        color: {
          scheme: "GnBu",
          reverse: false,
        },
        y: {
          labelAnchor: "Top",
          label: `Average time (minutes)`,
        transform: d => d / 60, // turn seconds into minutes
        grid: true,
      },
      x: {
        domain: ["Mo", "Tu", "We", "Th", "Fr", "Sa", "Su"],
        tickFormat: d => `${d}.`,
        label: null,
        tickSize: 0,
      },
      marks: [
      Plot.barY(xword_data.filter(d => (d.Solved === "True")), Plot.groupX({y: "mean"}, {y: "Time Taken", x: "Day of Week", fill: "Day of Week", fillOpacity: .8})),
      ]
    };

    const marker = xword_data.slice(394,395);

    var alltime = {
      width: width,
      style:{fontSize: size},
      marginTop: 50,
      color: {
        scheme: "GnBu",
        reverse: false,
      },
      y: {
        labelAnchor: "Top",
        label: `Average time (minutes)`,
        transform: d => d / 60, // turn seconds into minutes
        grid: true,
        domain: [0, 90],
      },
      x: {
        label: null,
      },
      marks: [
      Plot.line(xword_data.filter(d => (d.Solved === "True")), {x:"Puzzle Date", y:"Time Taken", curve: "catmull-rom", stroke:"hsl(230, 49%, 41%)"}),
      Plot.dot(xword_data.filter(d => (d.Solved === "True")), {x:"Puzzle Date", y:"Time Taken",fill:"hsl(230, 49%, 41%)", strokeWidth:0, r:2, title: d => `${d3.timeFormat("%A %B %d, %Y")(d["Puzzle Date"])}\nConstructor: ${d["Constructor"]}\n${d3.format(".4r")(d["Time Taken"]/60)} min to solve` }),

      Plot.text(marker, {x: "Puzzle Date", y: "Time Taken", text: d => `COVID-19 Pandemic`, dy: -10, dx: -8, rotate: 270}),
      Plot.ruleX(marker, {x: "Puzzle Date", strokeDasharray: [2, 2], strokeWidth: 0.5,stroke: "rgba(0, 0, 0, .75)"}),
      ]
    };

    var facet = {
      width: width,
      style:{fontSize: size},
      grid: true,
      // inset: 10,
      // width: 928,
      height: 350,
      marginBottom: 40,
      color: {
        scheme: "RdYlGn",
        reverse: true,
      },
      facet: {
        data: xword_data,
        x: "Day of Week",
      },
      fx: { 
      domain: ["Mo", "Tu", "We", "Th", "Fr", "Sa", "Su"], // Facet axis (top)
      label: null,
      tickFormat: d => `${d}.`,
    }, 
    x: {
        transform: d => d / 60, // turn seconds into minutes
        tickFormat: d => d == 100 ? `` : `${d}m`, // I want 3 ticks but don't want them to overlap
        label: "Time to solve (min.) →",
        nice: true,
        ticks: 3,
        tickSize: 0,
        labelOffset: 40,
      },
      y: {
        domain: ["Mo", "Tu", "We", "Th", "Fr", "Sa", "Su"], // y axis (left)
        label: null,
        tickSize: 0,
        tickFormat: d => `${d}.`,
      },
      marks: [
      Plot.frame({stroke: "#ccc"}),
      Plot.tickX(xword_data, Plot.groupY({x: "median"}, {filter: d => (d.Solved === "True"), y: "Day of Week", x: "Time Taken", stroke: "hsl(356, 75%, 53%)"})),
      Plot.dot(xword_data, {filter: d => (d.Solved === "True"),r:4, x: "Time Taken", y: "Day of Week", fill: "Time Taken", stroke: "Time Taken", title: d => `${d3.timeFormat("%B %d, %Y")(d["Puzzle Date"])}\nConstructor: ${d["Constructor"]}\n${d3.format(".4r")(d["Time Taken"]/60)} min to solve`}),
      ]
    };

    var constructors = {
      width: width,
      style:{fontSize: size},
      marginLeft: 200,
      marginTop: 40,
      marginBottom: 0,
      insetBottom: 0,
      color: {
        domain: ["Erik", "not"],
        range: ["hsl(123, 35%, 51%)", "rgba(204,204,204,.8)"],
      },
      x: {
        grid: true,
        labelAnchor: "right",
        label: "# of puzzles →",
        axis: "top",
        tickSize: 0,
        nice: true, 
      },
      y: { 
        labelAnchor: "top",
        tickSize: 0, 
      },
      marks: [
        // Plot.barY(xword_data, Plot.groupX({y: "count"}, {x: "Constructor"})),
        Plot.barX(xword_data, Plot.groupY({x: "count"}, {y: "Constructor", fill: d => d.Constructor === "Erik Agard" ? "Erik" : "not", sort: {y: "x", reverse: true, limit: 20}})),
        ]

      };

      document.getElementById("xword").appendChild(Plot.plot(xword));
      // document.getElementById("text_stats").appendChild(Plot.plot(text_stats));
      document.getElementById("week").appendChild(Plot.plot(week));
      document.getElementById("alltime").appendChild(Plot.plot(alltime));
      document.getElementById("facet").appendChild(Plot.plot(facet));
      document.getElementById("constructors").appendChild(Plot.plot(constructors));
    });
  </script>
</body>
</html>